操作系统功能：提高计算机硬件的利用率，方便用户，且伴随着器件的不断更新换代。

## 发展历史

1. 无操作系统时期：用机器语言把代码写在打孔纸带上，一个人用完了下一个人再用。
2. 单通批处理系统：引入卫星机，把IO放在它上面，二者可以并行工作。监督程序自动将任务加载到计算机中持续自动运行。但是依然需要一些人工，并且对CPU/Mem利用率不高，好多时间都在等IO。
3. 多道批处理系统：中断的出现，通道技术。是操作系统形成的标志。资源利用率高，不过
4. 分时系统
5. 实时系统
6. 其他操作系统

**中断** CPU收到该信号就暂停当前任务，完成后再继续

![[Pasted image 20221220165442.png]]![[Pasted image 20221220165506.png]]

## 操作系统的特征

### 并发

多个事件在同一时间段内发生。操作系统是一个并发系统，各进程间并发，系统与应用间并发，操作系统要完成并发过程的管理。

**并行** 同一时刻发生。多核处理器同一时刻有多个程序同时运行。

![[Pasted image 20221220165842.png]]

### 共享

多个进程共享系统资源。操作系统对资源合理分配，分为互斥共享（同时只允许一个用户使用）、同时共享（一段时间多个用户使用）。

### 虚拟

一个物理实体映射为若干逻辑实体。这能大幅提高资源利用率。CPU复用可以运行多个程序，虚拟内存可以

### 异步性

程序并发执行的顺序不确定。

## 操作系统的运行机制

**中断** 断点机制，中断后，允许CPU执行其他任务再回来。程序执行时间结束后，系统会发出中断，CPU会切换到下一个程序。硬件事件也会产生中断，随后设备发出输出完成中断信号，CPU进入核心态，操作系统开始工作。

CPU状态分为**核心态，用户态**。前者是操作系统运行的状态。能访问所有寄存器、存储区。后者只能执行非特权指令，不能破坏系统。程序状态寄存器（PSW）中的标志位指示处理器状态，0为用户态，1为核心态。

![[Pasted image 20221220172956.png]]

## 进程通信

### 进程基本概念

**进程** 就是正在运行的程序。其构成要素有如下几个：

- 内存 指令和数据都在内存中。
- 寄存器 有些程序会直接读写寄存器。还有些特殊的寄存器：程序计数器（PC／IP）指示程序当前在执行的指令；栈指针（SP）、帧指针（FP）用于管理函数参数栈、局部变量和返回地址。
- 存储设备 有的程序也会访问I/O。

进程的创建过程由操作系统完成，先将数据加载到内存，随后执行其他初始化工作。完成后，操作系统将控制权转移给程序的入口，大多数是`main()`。

### 进程状态

进程并非一直在运行，它也有多种状态。

- 运行 正在处理器上运行。
- 就绪 进程已经准备好运行。
- 阻塞 进程执行了某操作，需要等待该操作完成。例如磁盘访问等I/O操作。

### 上下文切换

运行一个进程时暂停去执行另一个进程。它的关键在于保存和重新加载进程上下文信息，例如寄存器。每个进程都有一个这样的结构，用于存储进程的描述信息等，称为进程控制块（PCB）。

### UNIX进程API

UNIX 系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：fork()和 exec()。进程还可以通过第三个系统调用 wait()，来等待其创建的子进程执行完成。

#### fork()

创建新进程。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]){
	printf("Hi, (pid:%d)\n", (int)getpid());
	int rc = fork();
	if(rc<0){
		fprintf(stderr, "failed\n"); exit(1);
	} else if (rc==0) { printf("Hi, child(pid:%d)\n", (int)getpid());
	} else { printf("Hi, parent of %d (pid:%d)\n" ,rc, (int)getpid());
	}

	return 0;
}
```

上面的代码中，fork在调用它的地方创建了一个原进程的复制，且这复制进程得到的rc是0，它和原程序并行执行。

#### wait()

用来等待子进程执行完毕。需要头文件`sys/wait.h`

```c
int wc=wait(NULL);
```

这应该在父进程调用。

#### exec()

有许多变体，execl(),execle(),execlp(),execv(),execvp()

```c
myargs[0] = strdup("wc");   // program: "wc" (word count) 
myargs[1] = strdup("p3.c"); // argument: file to count 
myargs[2] = NULL;          // marks end of array 
execvp(myargs[0], myargs); // runs word count
```

这系统调用会直接用新的程序覆盖当前程序，并重新开始运行。

### 生产者消费者模型

## 作业调度

![[Pasted image 20221227160508.png]]![[Pasted image 20221227162357.png]]![[Pasted image 20221227164022.png]]![[Pasted image 20221227165526.png]]![[Pasted image 20221227165940.png]]

![[Pasted image 20221227172748.png]]


