### 模型假设：

1. **生产时间可控假设：** 假设生产每种型号笔记本电脑的时间是固定的，即不会受到其他因素的影响而发生变化。
2. **销售预测准确性假设：** 假设公司对销售量的预测是准确的，即预测的销售量与实际销售量相符。
3. **利润不变假设：** 假设每台笔记本电脑的利润是固定的，不会受到其他因素的影响而发生变化。
4. **装配线加班时间可控假设：** 假设装配线加班时间的管理是可控的，即公司可以根据需要进行调整，而不会受到其他限制。
5. **优先满足老客户需求假设：** 假设公司优先满足老客户的需求，即在满足其他约束条件的前提下，尽可能多地满足老客户的需求。

### 模型分析：

1. **目标函数分析：** 目标函数旨在最大化公司的总利润，通过合理地分配不同型号笔记本电脑的生产数量来实现。
2. **约束条件分析：**
    
    限制装配线加班时间是刚性约束,其余是柔性约束.
    
    首先最重要的指标是充分利用正常的生产能力,因此将他的优先级列为第一级;
    
    其次,优先满足老客户的需求列为第二级;
    
    再次,把满足各种型号电脑的销售目标列为第三级;
    
    最后,把装配的加班时间尽可能少列为第四级.
    
    在第二三级中,三种电脑的每小时利润可以看作其权重,他们分别为$20,18,21$﻿.
    

### 模型构建：

1. **确定决策变量：** 设 $x_1， x_2 ， x_3 $﻿ 分别表示生产的 A 型，B 型和 C 型笔记本电脑的数量。
2. **建立目标函数：** 建立目标规划的函数
    
    $\min z = P_1(d_1)^- + P_2(20d_2^- +18d_3^- +21d_4^-) +P_3(20d_5^- + 18d_6^- +21d_7^-) + P_4(d_8^+)$﻿
    
3. **建立约束条件：**
    - 限制装配线加班时间是刚性约束,可表示为 $5x_1 +8x_2 +12x_3 \le 1900$﻿
    - 充分利用正常的生产能力为柔性约束,可表示为 $ \begin{cases} \min(d_1^-) \\5x_1 +8x_2 +12x_3 +d_1^--d_1^+ = 1700 \end{cases}$﻿
    - 优先满足老客户的需求为柔性约束，可表示为$\begin{cases}\min(20d_2^-+18d_3^-+21d_4^-)\\x_1 +d_2^--d_2^+= 50 \\ x_2 +d_3^- - d_3^+= 50 \\ x_3 +d_4^--d_4^+=80\end{cases}$﻿
    - 满足各种型号电脑的销售目标为柔性约束,可表示为 $\begin{cases}\min(20d_5^-+18d_6^-+21d_7^-)\\x_1 +d_5^--d_5^+= 100 \\ x_2 +d_6^- - d_6^+= 120 \\ x_3 +d_7^--d_7^+=100\end{cases}$﻿
    - 装配线的加班时间尽可能少为柔性约束,可表示为 $\begin{cases} \min(d_8^+) \\ 5x_1 + 8x_2 +12x_3 +d_8^- -d_8^+ = 1700\end{cases}$﻿
4. **确定整数约束：** 确保决策变量为整数，因为生产的笔记本电脑数量必须为整数。
5. **建立模型：**
    
    故相应的目标规划模型为
    
    $\begin{aligned}& \min z = P_1(d_1)^- + P_2(20d_2^- +18d_3^- +21d_4^-) +P_3(20d_5^- + 18d_6^- +21d_7^-) + P_4(d_8^+) \\& 使得 \\ & \begin{cases}5x_1 +8x_2 +12x_3 \le 1900 \\ 5x_1 +8x_2 +12x_3 +d_1^- -d_1^+ = 1700 \\ x_1+d_2^- -d_2^+ = 50\\ x_2+d_3^- -d_3^+ = 50 \\ x_3 + d_4^- - d_4^+ = 80 \\ x_1 +d_5^- - d_5^+ = 100 \\ x_2 +d_6^- -d_6^+ = 120 \\ x_3 + d^-_7 - d_7^+ = 100 \\5x_1 +8x_2 + 12x_3 +d_8^--d_8^+ = 1700\\ x_1,x_2,x_3 , d_i^-,d_i^+\ge 0,i=1,2,3,4,5,6,7,8 \end{cases} \end{aligned} $
    
6. **求解模型：** 使用目标规划的贯序方法求解建立的模型，得到最优解，即最大化公司总利润的生产方案。

  

## 代码与结果:

### 求解生产方案:

```MATLAB
% 创建优化变量
x3 = optimvar("x",3,1,"Type","integer","LowerBound",0);
dp3 = optimvar("dp",8,1,"LowerBound",0);
dm3 = optimvar("dm",8,1,"LowerBound",0);

% 设置求解器的初始起点
initialPoint.x = zeros(size(x3));
initialPoint.dp = zeros(size(dp3));
initialPoint.dm = zeros(size(dm3));

% 创建问题
problem = optimproblem;

% 定义问题目标
problem.Objective = dm3(1);

% 定义问题约束
problem.Constraints.constraint1 = 5*x3(1)+8*x3(2) +12*x3(3) <= 1900;
problem.Constraints.constraint2 = 5*x3(1)+8*x3(2)+12*x3(3) +dm3(1)-dp3(1) == 1700;
problem.Constraints.constraint3 = x3(1) + dm3(2) -dp3(2) == 50;
problem.Constraints.constraint4 = x3(2)+dm3(3)-dp3(3) == 50;
problem.Constraints.constraint5 = x3(3) +dm3(4) -dp3(4) == 80;
problem.Constraints.constraint6 = x3(1) + dm3(5)-dp3(5) == 100;
problem.Constraints.constraint7 = x3(2)+dm3(6)-dp3(6) == 120;
problem.Constraints.constraint8 = x3(3)+dm3(7)-dp3(7) == 100;
problem.Constraints.constraint9 = 5*x3(1)+8*x3(2)+12*x3(3)+dm3(8)-dp3(8) <= 1700;

% 设置非默认求解器选项
options = optimoptions("intlinprog","Display","final");

% 求解问题
[solution,objectiveValue4] = solve(problem,initialPoint,"Solver","intlinprog",...
    "Options",options);
    
    % 创建优化变量
x2 = optimvar("x",3,1,"Type","integer","LowerBound",0);
dp2 = optimvar("dp",8,1,"LowerBound",0);
dm2 = optimvar("dm",8,1,"LowerBound",0);

% 设置求解器的初始起点
initialPoint2.x = zeros(size(x2));
initialPoint2.dp = zeros(size(dp2));
initialPoint2.dm = zeros(size(dm2));

% 创建问题
problem = optimproblem;

% 定义问题目标
problem.Objective = 20* dm2(2)+18 *dm2(3)+ 21 *dm2(4);

% 定义问题约束
problem.Constraints.constraint1 = 5*x2(1)+8*x2(2) +12*x2(3) <= 1900;
problem.Constraints.constraint2 = 5*x2(1)+8*x2(2)+12*x2(3) +dm2(1)-dp2(1) == 1700;
problem.Constraints.constraint3 = x2(1) + dm2(2) -dp2(2) == 50;
problem.Constraints.constraint4 = x2(2)+dm2(3)-dp2(3) == 50;
problem.Constraints.constraint5 = x2(3) +dm2(4) -dp2(4) == 80;
problem.Constraints.constraint6 = x2(1) + dm2(5)-dp2(5) == 100;
problem.Constraints.constraint7 = x2(2)+dm2(6)-dp2(6) == 120;
problem.Constraints.constraint8 = x2(3)+dm2(7)-dp2(7) == 100;
problem.Constraints.constraint9 = 5*x2(1)+8*x2(2)+12*x2(3)+dm2(8)-dp2(8) <= 1700;
problem.Constraints.constraint10 = dm2(1) == 0;

% 设置非默认求解器选项
options2 = optimoptions("intlinprog","Display","final");

% 求解问题
[solution,objectiveValue] = solve(problem,initialPoint2,"Solver","intlinprog",...
    "Options",options2);
    
    % 创建优化变量
x5 = optimvar("x",3,1,"Type","integer","LowerBound",0);
dp5 = optimvar("dp",8,1,"LowerBound",0);
dm5 = optimvar("dm",8,1,"LowerBound",0);

% 设置求解器的初始起点
initialPoint4.x = zeros(size(x5));
initialPoint4.dp = zeros(size(dp5));
initialPoint4.dm = zeros(size(dm5));

% 创建问题
problem = optimproblem;

% 定义问题目标
problem.Objective = 20* dm5(5)+18 *dm5(6)+ 21 *dm5(7);

% 定义问题约束
problem.Constraints.constraint1 = 5*x5(1)+8*x5(2) +12*x5(3) <= 1900;
problem.Constraints.constraint2 = 5*x5(1)+8*x5(2)+12*x5(3) +dm5(1)-dp5(1) == 1700;
problem.Constraints.constraint3 = x5(1) + dm5(2) -dp5(2) == 50;
problem.Constraints.constraint4 = x5(2)+dm5(3)-dp5(3) == 50;
problem.Constraints.constraint5 = x5(3) +dm5(4) -dp5(4) == 80;
problem.Constraints.constraint6 = x5(1) + dm5(5)-dp5(5) == 100;
problem.Constraints.constraint7 = x5(2)+dm5(6)-dp5(6) == 120;
problem.Constraints.constraint8 = x5(3)+dm5(7)-dp5(7) == 100;
problem.Constraints.constraint9 = 5*x5(1)+8*x5(2)+12*x5(3)+dm5(8)-dp5(8) <= 1700;
problem.Constraints.constraint10 = dm5(1) == 0;
problem.Constraints.constraint11 = 20* dm5(2)+18 *dm5(3)+ 21 *dm5(4) == 0;

% 设置非默认求解器选项
options4 = optimoptions("intlinprog","Display","final");

% 求解问题
[solution,objectiveValue3] = solve(problem,initialPoint4,"Solver","intlinprog",...
    "Options",options4);
    
    % 创建优化变量
x4 = optimvar("x",3,1,"Type","integer","LowerBound",0);
dp4 = optimvar("dp",8,1,"LowerBound",0);
dm4 = optimvar("dm",8,1,"LowerBound",0);

% 设置求解器的初始起点


initialPoint3.x = zeros(size(x4));
initialPoint3.dp = zeros(size(dp4));
initialPoint3.dm = zeros(size(dm4));

% 创建问题
problem = optimproblem;

% 定义问题目标
problem.Objective = dp4(8);

% 定义问题约束
problem.Constraints.constraint1 = 5*x4(1)+8*x4(2) +12*x4(3) <= 1900;
problem.Constraints.constraint2 = 5*x4(1)+8*x4(2)+12*x4(3) +dm4(1)-dp4(1) == 1700;
problem.Constraints.constraint3 = x4(1) + dm4(2) -dp4(2) == 50;
problem.Constraints.constraint4 = x4(2)+dm4(3)-dp4(3) == 50;
problem.Constraints.constraint5 = x4(3) +dm4(4) -dp4(4) == 80;
problem.Constraints.constraint6 = x4(1) + dm4(5)-dp4(5) == 100;
problem.Constraints.constraint7 = x4(2)+dm4(6)-dp4(6) == 120;
problem.Constraints.constraint8 = x4(3)+dm4(7)-dp4(7) == 100;
problem.Constraints.constraint9 = 5*x4(1)+8*x4(2)+12*x4(3)+dm4(8)-dp4(8) <= 1700;
problem.Constraints.constraint10 = dm4(1) == 0;
problem.Constraints.constraint11 = 20* dm4(2)+18 *dm4(3)+ 21 *dm4(4) == 0;
problem.Constraints.constraint12 = 20* dm4(5)+18 *dm4(6)+ 21 *dm4(7) == 1590;

% 设置非默认求解器选项
options3 = optimoptions("intlinprog","Display","final");

% 求解问题
[solution,objectiveValue2] = solve(problem,initialPoint3,"Solver","intlinprog",...
    "Options",options3);
    
    disp(solution.x);
    disp(1000*solution.x(1) + 1440*solution.x(2) + 2520*solution.x(3));
```

### 运行结果:

![[知识/杂项/作业/计算机公司生产问题/pictures/Untitled.png|Untitled.png]]

  

  

![[知识/杂项/作业/计算机公司生产问题/pictures/Untitled 1.png|Untitled 1.png]]

  

### 结果分析:

由代码运行结果可以看出,在上述目标要求下,最佳的生产方案为生产型号A100台，生产型号B55台，生产型号C80台，在这种方案下，能够按照目标的优先级满足目标,同时也实现了利润的最大化,最大利润预计为380800元.