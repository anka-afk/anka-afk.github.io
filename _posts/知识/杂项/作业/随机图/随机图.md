### 模型假设：

1. 图中的顶点表示实体，顶点之间的边表示连接这些实体的关系。
2. 每对顶点之间以概率 0.6 存在一条边，表示图是一个随机生成的稀疏图。
3. 边的权重为 [1,10] 上的随机整数，表示不同边之间的权重具有随机性。
4. 求解顶点 v1 到顶点 v10 的最短距离及最短路径，意味着我们要寻找图中顶点之间的最短路径，即通过最少的边来连接 v1 和 v10。

### 模型分析：

1. 我们可以使用图论中的最短路径算法来解决这个问题，例如 Dijkstra 算法或 Floyd-Warshall 算法。
2. 给定图的顶点数量和边的连接概率，我们可以使用随机图生成算法来创建图的邻接矩阵或邻接表。
3. 最短路径算法的时间复杂度取决于图的规模和边的数量，因此需要考虑算法的效率以及计算资源的限制。

### 模型构建：

1. 构建一个包含 10 个顶点的无向图。
2. 在图中的每一对顶点之间以概率 0.6 添加一条边，并为每条边随机分配一个权重，权重范围为 [1,10]。
3. 使用 Dijkstra 算法来计算顶点 v1 到顶点 v10 的最短路径及距离。
4. 输出最短路径及距离的结果。

## 代码与结果:

### 求解最短路径:

```MATLAB
clc;
clear;

% 生成随机图的参数
num_vertices = 10; % 顶点数
probability = 0.6; % 边存在的概率
weight_range = [1, 10]; % 边的权重范围

% 生成随机图的邻接矩阵
s = [];
t = [];
W = [];
for i = 1:num_vertices
    for j = i+1:num_vertices
        if rand() < probability
            weight = randi(weight_range);
            s = [s i];
            t = [t j];
            W = [W weight];
        end
    end
end

% 构建图对象
names = cellstr(strcat('v', int2str((1:num_vertices)')));
G = graph(s, t, W, names);

% 绘制图并标记顶点
figure;
PG = plot(G, 'EdgeLabel', G.Edges.Weight);
title('随机生成的无向图');
xlabel('顶点编号');
ylabel('顶点编号');

% 使用 Dijkstra 算法计算最短路径
[source, target] = deal(1, num_vertices);
[path, dist, pred] = shortestpath(G, source, target, 'Method', 'positive');

% 高亮显示最短路径
highlight(PG, path, 'EdgeColor', 'r', 'LineWidth', 1.5);

% 输出最短距离及最短路径
fprintf('顶点 v%d 到顶点 v%d 的最短距离为：%f\n', source, target, dist);
fprintf('最短路径为：v%d', source);
for i = 2:length(path)
    fprintf(' -> v%d', path(i));
end
fprintf('\n');
```

### 运行结果：

![[知识/杂项/作业/随机图/pictures/Untitled.png|Untitled.png]]

### 结果分析：

由运行结果可以发现，在这种随机情况下，最短路径为v1到v2到v10，路径长度为7.