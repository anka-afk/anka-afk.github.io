算法简介

定义 算法的定义

性能

算法的核心

简单的算法:二分查找

运行时间，大O表示法

# 算法简介

## ==_**定义 算法的定义**_==

> _算法是一组完成任务的指令_
> 
>   
> 
> 是一段代码片段

---

## _**性能**_

不同算法有不同的优缺点

有时候合并排序算法好用,有时快速排序算法好用

有时候数组合适,有时候链表合适

因此要**因地制宜**

---

## 算法的核心

算法的核心是**解决问题的技巧**

  

我们需要知道,面对不同的,复杂的问题

我们要**从什么方面**着手解决

怎么样解决**更好**

---

## 简单的算法:二分查找

如果要查找1到100这100个数中的一个数,我们最好怎么办?

  

二分查找需要输入**有序**的列表

  

随便想一个数字,我们会得知这个数字是大了还是小了

最朴素的想法是从1开始一个一个猜

这就是**简单查找**(傻找

  

我们需要**更好**的查找方式

  

我们直接从**50**开始猜

这样,我们可以直接排除一半

接下来,我们一直从中间猜,每次都能排除一半!

这就是**二分查找**

二分查找的效率**远远高于**简单查找

  

如果一个字典有240000个词,简单查找需要240000步 ,而二分查找仅仅需要18步!

  

对于一个包含$n$﻿个元素的**有序**列表

简单查找最多需要$n$﻿步

二分查找最多需要$\log_2 n$﻿步(对数时间)

```Python
# 这是一个简单的二分查找代码

#我们定义一个函数
def binary_search(list,item):
    low = 0
    high = len(list) - 1
# 用于追踪要查找的列表部分
    while low <= high:# 当范围没有缩小到只有一个元素
        mid = (low + high)
        guess = list[mid]# 检查中间的元素
        if guess == item:
            return mid
        if guess > item:
            high = mid - 1# 大了就猜下半部分
        else:
            low = mid + 1# 小了就猜下半部分
    return None# 没有查找到这个元素
# 函数结束


my_list = [1,3,5,7,9]# 定义一个列表试试
print(binary_search(my_list,3))
print(binary_search(my_list,7))
```

---

## 运行时间，大O表示法