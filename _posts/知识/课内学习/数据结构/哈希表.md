# 哈希表的特点

哈希表是一种基于**数组**的数据结构，而数组扩容成本很高，所以哈希表在被填满后性能下降严重

哈希表的思想是转换思想，即把[键]或[关键字]转换为数组的下标来进行查找，这个转换过程我们使用**哈希函数**

---

# 哈希函数

哈希函数是一种映射，它把[键]或者[关键字]映射成一个整数(int)，用来作为数组的下标

---

# 哈希冲突

哈希冲突是指，存在两个**不同的键**对应了**相同的值**

哈希冲突是不可避免的，我们常用**开放地址法**和**链表法**解决哈希冲突

---

## 开放地址法

### 线性探测

线性探测名称的由来是，它是以线性间隔探测哈希表，即每次地址+1

线性探测的思想是，如果我们要使用的地址已经存了数据，我们就看看下一个地址有没有存元素，如果下一个地址没有存元素，我们就可以把这个元素存进去，以此往复。

例如：我们要存东西的数组下标是16，但是我们发现之前已经往16这个位置存了东西了，那我们就去访问17这个位置，看看17有没有东西，如果没有，我们就把这个东西存在17这个位置，如果17也已经存了东西 我们就去检查18，以此往复。

简单来说，如果出现哈希冲突的下标是x，那我们就去探测x+1，x+2，x+3…

---

## 二次探测

二次探测不怎么使用，它比线性探测好，但我们有更好的

线性探测每次地址+1的做法会导致如果存在多个哈希冲突，从某一个哈希冲突发生开始，后面存入的项只能在后面一位一位存入，就会导致哈希表在某一个地方开始，后面存满了一堆数据，这就是线性探测的聚集问题。

如果这个时候我们再往聚集的一堆数据的第一项的位置存入数据，这时为了消除这个哈希冲突，这个数据会和后面聚集的数据一一产生哈希冲突，然后最后还是放到这个聚集堆的最后面。

为了减少线性探测的聚集问题，我们的思想是：每次探测相隔远一点的单元，而这个间隔我们就选择二次函数，这就是二次探测名称的由来

简单来说，如果出现哈希冲突的下标是x，我们就去探测x+1，x+4，x+9，x+16…

即使如此，还是会出现聚集，这种聚集我们称为二次聚集，具体如下：加入我们有5个元素，分别为5，11，16，42，65，他们都映射到x这个位置，那么11就需要从x+4这个位置开始探测，16就需要从x+16这个位置开始探测，42就需要从x+25这个位置开始探测，65就需要从x+36这个位置开始探测，如果有更多映射到x的元素，就需要从更远的地方开始探测，这就是二次聚集

---

### 双哈希

双哈希是为了消除前面出现的聚集问题，因为不管是哪种探测，如果出现在x出现多次哈希冲突，还是需要走一样的步长来找空位

双哈希的方法具体如下：除了用来生成下标的哈希函数之外，我们再添加一个哈希函数，用来根据关键字生成探测法的步长，这样即使第一个哈希函数把两个关键字映射到同一个下标，但是大部分情况第二个哈希函数生成的他们探测的步长不一样，就不会出现聚集问题了，如果两个哈希函数映射的结果都相同，这也太巧了吧，只能改进哈希函数了。

第二个哈希函数需要满足以下条件：

1. 和第一个哈希函数不一样
2. 不能输出0，一旦输出0，就会产生死循环，一直探测一个位置

根据经验，stepSize = constant-(key%constant)这种哈希函数效果很好，constant是一个比存放哈希表的数组大小要小的质数

双哈希的效果很好，那么代价是什么呢？

代价是，双哈希要求存放哈希表的数组的大小是一个质数

例子：

假设哈希表的大小是15，关键字a经过第一个哈希函数得到的下标是0，经过第二个哈希函数得到的步长是5，那么探测过程为：0，5，10，0，5，10…永远都只会尝试这三个位置，永远都找不到空位，永远都停不下来

假设哈希表的大小是13，关键字a经过第一个哈希函数得到的下标是0，经过第二个哈希函数得到的步长是5，那么探测过程为：0，5，10，2，7，12，4，9，1，6，11，3。可以看出，最后会遍历存放哈希表的数组的每一个位置

---

总结：开放地址法的每种策略都有各种问题，所以不常使用，如果使用开放地址法，双哈希策略使用较多

---

## 链表法

  

  

# 构造哈希函数

哈希函数的构造本质上是对元素进行分类，好的哈希函数就是一种良好分类，能把元素分的足够开，足够细

### 除余法

除余法的具体操作如下：

选择一个适当的正整数p，

哈希函数h(k)=k mod p

也就是说，这个哈希函数把k转换为k除以p的余数

这是最直观的一种方法，也很容易实现，不过容易出现哈希冲突