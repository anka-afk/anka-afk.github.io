在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)里，**树的遍历**（也称为**树的走访**或**树的搜索**）是一种[图的遍历](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86)，指的是按照某种规则，不重复地访问某种[树](https://zh.wikipedia.org/wiki/%E6%A8%B9_(%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B))的所有节点的过程。具体的访问操作可能是检查节点的值、更新节点的值等。不同的遍历方式，其访问节点的顺序是不一样的。以下虽然描述的是[二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)的遍历算法，但它们也适用于其他树形结构。

---

# **遍历的种类**

与那些基本上都有标准遍历方式（通常是按线性顺序）的[线性数据结构](https://zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&action=edit&redlink=1)（如[链表](https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8)、一维[数组](https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84)）所不同的是，树结构有多种不同的遍历方式。

从二叉树的根节点出发，节点的遍历分为三个主要步骤：

对当前节点进行操作（称为 “访问” 节点）、遍历左边子节点、遍历右边子节点。这三个步骤的先后顺序也是不同遍历方式的根本区别。

  

由于从给定的某个节点出发，有多个可以前往的下一个节点（树不是线性数据结构），所以在顺序计算（即非并行计算）的情况下，只能推迟对某些节点的访问 —— 即以某种方式保存起来以便稍后再访问。常见的做法是采用[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（LIFO）或[队列](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97)（FIFO）。由于树本身是一种自我引用（即递归定义）的数据结构，因此很自然也可以用[递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92)方式，或者更准确地说，用[共递归](https://zh.wikipedia.org/wiki/%E5%85%B1%E9%80%92%E5%BD%92)，来实现延迟节点的保存。这时（采用递归的情况）这些节点被保存在[调用堆栈](https://zh.wikipedia.org/wiki/%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A)中。

  

遍历方式的命名，源于其访问节点的顺序。

最简单的划分：是深度优先（先访问子节点，再访问父节点，最后是第二个子节点）？还是广度优先（先访问第一个子节点，再访问第二个子节点，最后访问父节点）？

  

深度优先可进一步按照根节点相对于左右子节点的访问先后来划分。

如果把左节点和右节点的位置固定不动，那么根节点放在左节点的左边，称为前序（pre-order）、根节点放在左节点和右节点的中间，称为中序（in-order）、根节点放在右节点的右边，称为后序（post-order）。

  

对广度优先而言，遍历没有前序中序后序之分：给定一组已排序的子节点，其 “广度优先” 的遍历只有一种唯一的结果。

---

# **深度优先遍历**

分作**前序遍历**、**中序遍历**、**后序遍历**，前、中、后代表根节点在遍历时的位置。以下透过 [C 语言](https://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80)实现，并均使用[递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))方法

  

## **前序遍历** 

前序遍历（Pre-Order Traversal）是依序以**根节点、左节点、右节点**为顺序遍历的方式。 其遍历顺序是：

![[知识/课内学习/数据结构/树/树的遍历/pictures/Untitled.png|Untitled.png]]

```C
void pre_order_traversal(TreeNode *root) {
    // Do Something with root
    if (root->lchild != NULL) //若其中一側的子樹非空則會讀取其子樹
        pre_order_traversal(root->lchild);
    if (root->rchild != NULL) //另一側的子樹也做相同事
        pre_order_traversal(root->rchild);
}
```

---

## **中序遍历**

中序遍历（In-Order Traversal）是依序以**左节点、根节点、右节点**为顺序遍历的方式。 其遍历顺序是：

![[知识/课内学习/数据结构/树/树的遍历/pictures/Untitled 1.png|Untitled 1.png]]

```C
void in_order_traversal(TreeNode *root) {
    if (root->lchild != NULL) //若其中一側的子樹非空則會讀取其子樹
        in_order_traversal(root->lchild);
    // Do Something with root
    if (root->rchild != NULL) //另一側的子樹也做相同事
        in_order_traversal(root->rchild);
}
```

---

## 后序遍历

后序遍历（Post-Order Traversal）是依序以**左节点、右节点、根节点**为顺序遍历的方式。 其遍历顺序是：

倒着看,左节点当右节点,右节点当左节点和先序的一样

![[知识/课内学习/数据结构/树/树的遍历/pictures/Untitled 2.png|Untitled 2.png]]

```C
void post_order_traversal(TreeNode *root) {
    if (root->lchild != NULL) //若其中一側的子樹非空則會讀取其子樹
        post_order_traversal(root->lchild);
    if (root->rchild != NULL) //另一側的子樹也做相同事
        post_order_traversal(root->rchild);
    // Do Something with root
}
```

---

# 广度优先遍历

和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按**层次遍历**。算法借助队列实现。 其遍历顺序是：

![[知识/课内学习/数据结构/树/树的遍历/pictures/Untitled 3.png|Untitled 3.png]]

```C
void level(TreeNode *node)
{
  Queue *queue = initQueue();
  enQueue(queue, node);

  while (!isQueueEmpty(queue))
  {
    TreeNode *curr = deQueue(queue);

    // Do Something with curr

    if (curr->lchild != NULL)
      enQueue(queue, curr->lchild);
    if (curr->rchild != NULL)
      enQueue(queue, curr->rchild);
  }
}
```

---

# 多叉树的遍历

## **深度优先遍历**

先访问根结点，后选择一子结点访问并访问该节点的子结点，持续深入后再依序访问其他子树，可以轻易用[递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))或[栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A)的方式实现。

```C
void travel(treenode* nd){
    for(treenode* nex :　nd->childs){ //childs存放指向其每個子結點的指標
        travel(nex);   
    }
    return;
}
```