机器指令是用机器字表示的，也就是二进制表示，这条机器字也叫指令字

# 指令格式

是指令字用二进制代码表示的结构形式

操作码+地址码

  

## 地址码

按照地址码的数量可以把指令格式分为

1. 四地址指令

把第一个地址的东西和第二个地址的东西进行操作，把结果放在第三个地址位置，第四个地为下一条指令的地址

可以连续执行指令

1. 三地址指令

就是把四地址指令的最后一个存下一条指令的地址删了

用这种格式的机器肯定有一个指针监控这一段地方，来确定下一步操作

1. 二地址指令

就是把四地址的后两个地址删了，把运算结果放到第一个地址里

第二个地址操作后不会变，所以也叫元操作数地址

1. 一地址指令

就是把四地址的后三个都删了，用于单目运算（如自增），隐含另一个操作数

1. 零地址指令

  

程序长度和程序存储量分别是行数和列数，像一个矩阵一样

---

## 操作码

操作码的长度决定了计算机能够进行的指令条数

例如 $8$﻿位操作码可以表示 $2^8$﻿条不同的指令

  

### 操作码的编码

1. 规整型（定长编码）

  

1. 非规整型（变长编码）

是操作码扩展技术的应用，操作码分散的存在指令的不同字段中

可以压缩操作码的平均长度

充分利用了操作码剩余的空间

增加了译码和分析的难度

  

### 操作码扩展技术

有些指令用不到多的地址，这些地方是空着的，我们要把这些位置用起来

  

$4$﻿位基本操作码若全部用于三地址指令，则有 $16$﻿条

我们不用完，留下一个 $1111$﻿作为标志，表示这个不是操作码，这个时候我们可以把第一个地址的地方当作操作码用

  

接下来同样留下 $11111111$﻿作为标志，又扩展第二个地址的地方作为操作码

  

可以由三地址指令扩展为：

15条三地址指令

15条二地址指令

15条一地址指令

16条零地址指令

一共61条

  

在指令长度不变的情况下，增加了指令数量

频率高的操作码要分配短的操作码

频率低低操作码要分配长的操作码

  

注意：不允许短码是长码的前缀，不同操作的操作码不能重复

  

# 寻址技术

寻址是指寻找操作数的地址和下一条指令的地址

包括编址方式和寻址方式

  

编址方式

需要编址的设备：

1. CPU中的通用寄存器
2. 主存储器
3. 输入输出设备

编址单位

  

指令中地址码位数

和主存容量和最小寻址单位（编址单位）相关

主存容量越大，需要的地址码位数就越长

- 例子
    
    设某机的主存容量为 $2^{30} B = 1 GB$﻿,机器字长为 $32$﻿位
    
    计算机32位字长中30位存地址码，两位是操作码和其他东西
    
      
    

  

## 指令寻址与数据寻址

指令寻址分为顺序寻址和跳跃寻址

顺序寻址依赖于程序计数器实现，看上去就是一个队列

  

跳跃寻址其实就是把一些指令的内容变为控制指令顺序的指令，来跳转到其他指令

类似于 `goto` ，即下一条指令的地址是由指令本身给出的

  

## 指令寻址

- 顺序寻址
- 跳跃寻址

## 数据寻址

- 目的:找到操作数

操作数寻址方式:

根据指令中给出**形式地址**$A$﻿寻找真实操作数**有效地址**$EA$﻿的方式:

  

寻址方式设计要求:

- 地址尽可能短,省空间
- 寻址空间尽可能大,兼容大内存
- 地址计算尽可能简单,提高速度

  

### 立即寻址

指令中的地址字段直接就是操作数本身(用二进制表示的)

  

- 取出指令的同时取出操作数
- 执行时间很短
- 指令执行阶段无需访问主存
- 操作数的位数限制了范围(受指令位数限制)

  

### 寄存器寻址

指令中地址码部分给出一个通用**寄存器**的编号,操作数存在寄存器里

去寄存器取操作数就行了

- 有效地址即寄存器编号(例如1,2,3)
- 执行阶段不访问主存,访问**寄存器**,速度快
- 寄存器个数有限(不会多于三位数),指令字长短

  

### 直接寻址

**有效地址**由**形式地址**直接给出,操作数放在**主存**中

- 执行阶段访问一次**存储器**
- 形式地址的位数限制了操作数的寻址范围
- 操作数的地址不易修改(要直接修改指令本身$A$﻿)

  

### 间接寻址

指令给出的地址$A$﻿不是操作数的地址,而是操作数**地址的地址**(套娃)

也就是地址$A$﻿指向一个**指针**,这个指针再指向操作数

- 指令格式中用$@$﻿作为**标志位**,$\begin{cases}@ = 0 \quad 直接寻址 \\ @=1 \quad 间接寻址 \end{cases}$﻿
- 可以扩大寻址空间
- 由于需要多次寻找地址,速度**慢**
- 可以将主存单元的一部分作为程序的地址指针,用来指示操作数在主存的位置

### 多级间接寻址

和间接寻址方式一样,只不过是多层套娃

- 指令格式中用$@$﻿作为**多级间接标志**,$\begin{cases}@ = 0 \quad 找到有效地址 \\ @=1 \quad 继续间接寻址 \end{cases}$﻿
- 微型机中没有这种寻址方式(大型机会用)

### 寄存器间接寻址

指令的地址码给出某个**寄存器编号**,这个寄存器中存放操作数的**有效地址**

**地址码**指出寄存器

**寄存器**存放操作数地址

**主存**中存放操作数

- 执行阶段访问一次主存
- 和间接寻址类似,只不过指针存放在寄存器
- 指令短,速度快
- 和直接寻址相比更灵活
- 多用于表处理

  

### 变址寻址

把指令给出的形式地址和**变址寄存器**$R_x$﻿的内容进行**相加**,得到操作数的**有效地址**,再去**主存**中寻找操作数

- 灵活,速度慢
- 面向用户,用于访问字符串,数组等
- 执行阶段访问主存
- 数组对象名相当于一个形式地址(不变的),这时变址寄存器相当于数组下标变化

  

### 基址寻址

把**基址寄存器**$R_b$﻿的内容与**位移量**$D$﻿相加,得到操作数的有效地址,再去**主存**中寻找操作数

- 灵活,速度慢
- 面向系统,用于逻辑地址和物理地址的变换,用于程序在主存的再定位和扩大寻址空间
- 例如访问数组$a[1]$﻿,其实是把数组首地址$a$﻿加上一个单位的偏移得到
- 执行阶段访问主存
- 常在大型机使用

  

### 相对寻址

相对于当前**程序计数器**$PC$﻿寻址,表示为:

$EA=(PC)+D$

偏移量$D$﻿为操作数和当前指令的**相对位置**

- 和基址寻址类似,只不过是从程序计数器出发

  

### 页面寻址

> 页:  
> 是将整个主存分为若干个大小相同的容量,这一小块内存称为页  

> 页面地址:  
> 每页的编号  

> 页内地址:  
> 页面内每个主存编号的地址  

操作数的有效地址分为两个部分,页面地址+页内地址

  

> 页面标志位($Z/C$﻿)

程序计数器的高位拼接在前面,程序计数器四个字节,前两个字节为高位

拼接操作比相加要快

  

## 区分寻址方式

### 显式区分

在指令中设计专门的 **寻址方式字段**,用二进制代码表示**寻址方式**

  

### 隐式区分

在操作码中说明

  

# 堆栈

后进先出

实现有两种方式:

1. 硬堆栈(寄存器堆栈)
    - 栈顶是固定的
    - 大小不可变
    - 有对应位自动推移功能,把内容推到相邻的寄存器
2. 软堆栈
    - 从主存中划分堆栈区,大小可变
    - 栈底固定,栈顶浮动
    - 有一个专门的寄存器(SP)存放堆栈栈顶指针

## 堆栈操作

下面用SP表示存放的栈顶指针的寄存器

### 进栈

SP的内容自动减一,然后将数据压入堆栈

`PUSH`

### 出栈

先将堆栈中的数据弹出,然后将SP的内容自动加一

`POP`

  

堆栈操作通过调整栈顶指针对栈顶位置的数据进行操作

用于访问堆栈的指令只有两种: 进栈和出栈

堆栈的作用:主要用于**暂存**

1. 中断断点
2. 存放子程序调用时的返回地址(递归),状态标志和现场信息,还能用于函数嵌套的参数传递

  

例子

在堆栈计算机中,使用堆栈保存操作数和运算结果

使用零地址指令,从栈中弹出操作数进行计算

  

算术逻辑表达式的表示法

1. 中缀式(中序遍历)
2. 前缀式(波兰法)(先根遍历)
3. 后缀式(逆波兰法)(后根遍历)

机器使用的是后缀式,从左到右读取,碰到数字就进栈,碰到运算符就弹出对应数目的操作数,进行运算,然后将结果进栈,其中先弹出的结果作为右操作数

- 对软堆栈,需要访问四次主存
- 对硬堆栈,只需要访问一次主存

  

# 指令类型

## 数据传送类指令

- 一般传送
- 堆栈操作
- 数据交换指令

## 运算类指令

- 算术运算
- 逻辑运算
- 移位指令

## 程序控制类指令

- 转移
- 子程序调用
- 返回指令

## I/O类指令

- 输入
- 输出

例子: PDP-11指令系统,8086/8088指令系统

# 指令系统的发展

不同计算机有不同的指令系统

## x86架构的扩展指令集

目前主流的机器都采用

为了提升各方面的性能,几个公司各自开发了一些新的扩展指令集

  

## 从复杂指令系统到精简指令系统

- CISC—复杂指令集计算机  
    随着系列机的问世,指令系统的条数越来越多  
    体现了计算机性能越高,指令系统越复杂的传统设计思想  
    给高级语言提供了更好的支持  
    使目标程序得到优化  
    为操作系统提供支持  
      
    问题  
    - 庞大的指令集
    - 复杂的寻址方式
    - 硬件实现复杂(硬件资源利用率低)
    - 机器开发成本高
    - 结构复杂
    - 速度慢
- RISC—精简指令集计算机
    
    来源: 2-8法则
    
    用20%的简单指令实现另外不常用的80%复杂指令
    
    - 不是简单简化指令系统,而是使得计算机的结构更加简单合理
    - 简化的指令系统: 指令少,寻址方式少,指令格式少,指令长度统一
    - 以寄存器—寄存器方式操作,只有读数—取数操作可以访问主存,其余指令只能访问寄存器
    - 大量通用寄存器