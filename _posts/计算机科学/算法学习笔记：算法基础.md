---
title: 算法学习笔记：算法基础
tags:
  - 算法
excerpt: 作为我学习的记录。700+页，不知道多久能看完
toc: true
author: xeonds
date: '2021.11.12 23:52:34'
categories:
  - 计算机科学
---
我看的是机械工业出版社的算法导论（Introduction to Algorithms），据说不错。下面是我的读书笔记。

>最近又找了本书看，笔记做一块算了

# Chap1.排序算法

## 桶排序

创建一个桶，将待排序的值按照某项值放到对应的桶中，即排序完成。按桶的下标顺序输出即可得到排序后结果：

```python
data = [1,2,3,3,5,3,5]
arr = [0 for i in range(min(data),max(data))]

for i in arr:
    # put data in bucket
    arr[i]++;

# echo result
for i in arr:
    for j in range(i):
        print(i)
```

### 优点

因为读取即排序，所以速度非常快，时间复杂度为O(M+N)。M是桶长度，N是数据长度。

### 缺点

依赖下标顺序，因此数值过大时会过于浪费空间。

## 冒泡排序

像冒泡一样反复按顺序比较两个相邻值，顺序错误则交换二者。

```python
data = [...]

for i in range(data.length-1):
    for j in range(i,data.length-1):
        # exchange nearby value, to bigger
        if data[j]>data[j+1]:
            data[j],data[j+1]=data[j+1],data[j]
```

### 优点

名字好听

### 缺点

时间复杂度太高，达到O(n^2)

## 快速排序

采用分治思想的排序算法。将数据二分并选择基准数，使左侧数都小于基准数，右侧均大于基准数。

对于二分后的子序列，继续使用相同的方法处理即可，也就是递归处理。

```python
data = [...]

def QUICK_SORT(data,i,j):
    base,end = i++,j
    while i<j:
        while data[j]>data[base]:
            j--
        while data[i]<data[base] and:
            i++
        data[i],data[j]=data[j],data[i]
    data[base],data[j]=data[j],data[base]
    if end-base>3:
        QUICK_SORT(data,base,i)
        QUICK_SORT(data,i,end)
```

### 优点

平均时间复杂度较低平均为O(NlogN)，且节省空间。

### 缺点

速度取决于基准值的选择，最慢为O(N^2)

## 插入排序

它在处理小规模数据时很有效。过程类似于我们抽取扑克牌：先摸一张，将它和手上的牌从左到右比大小并插入到正确的位置。这样，我们手中的牌就始终是排序好的。

下面是它的代码。

>原书是伪代码，我翻译成C语言了

```c
void insertion_sort(int* arr,int arrSize)
{
    for(int j=2;j<arrSize;j++)
    {
        int i,key=arr[j];
        
        i=j-1;
        while(i>0&&arr[i]>key)
        {
            arr[i+1]=arr[i];
            i--;
        }
        arr[i+1]=key;
    }
}
```

# Chap2.数据结构基础

## 队列

先入先出的数据结构。有两个操作，入队和出队。第一个入队的也是第一个出队的。

```c
// struct defination
typedef struct{
    int data[64];
    int head=0,tail=0;
}Queue;

int pop(Queue *q){
    if(*q && q->head < q->tail){
        return q->data[q->head++];
    }else{
        return NULL;
    }
}

int push(Queue *q, int data){
    if(*q && q->tail < 63){
        q->data[q->tail++] = data;
    }else{
        return NULL;
    }
}
```

可以看到，这种队列需要预先分配好空间，不太灵活，后面可以用链表优化这种结构。

## 栈

先入后出的数据结构。同样有push和pop的操作。

```c
typedef struct{
    int data[64];
    int top=0;
}Stack;

int pop(Stack* s){
    if(*s && s->top>0){
        return s->data[s->top--];
    }else{
        return NULL;
    }
}

int push(Stack* s, int data){
    if(*s && s->top<64){
        return s->data[s->top++]=data;
    }else
    {
        return NULL;
    }
}
```

## 链表

一个非常灵活，但相比于数组不具有随机访问能力的数据结构。

```c
typedef struct node{
    int data;
    node* next;
}Node;
```

上面是链表节点的结构。包含指向下个节点的指针和数据。链表支持CRUD（创建，查询，修改，删除）操作，时间复杂度是常数。

# Chap3.枚举算法

略

# Chap4.搜索算法

## 深度优先搜素（Depth First Search）

类似于树的遍历，先沿着一个方向遍历，到头后返回上一个节点，遍历另一条路径。其核心思想是“这一步应该怎么做”，而下一步的做法和这一步是一样的：

```python
data = [...]
nodes = set('abcdef')

def dfs(data, node, pos=0, result=''):
    def verify(res):
        # your code here...
        pass
    
    # current position is the next of last element of array
    if pos==data.length:
        if (verify(result)):
            print(result)
    else:
        for i in node:
            dfs(data, node-i, pos+1, result+i)

dfs(data, nodes)
```

### 优点

代码和实现都很简洁

### 缺点

很明显，因为采用了递归，所以有很高的时间复杂度

## 广度优先搜索（Breadth First Search）

核心思想是“扩展”。对于一个数据空间（可能是各种数据结构），以一个样本为起点，向周围所有可拓展的数据点拓展，并对已经处理过的数据点进行标记。这个点处理过后，将这个数据点从处理队列中消去，并对新拓展的数据点进行相同处理。

每次处理时对数据点进行判断，将最符合条件的数据点进行存储即可。

下面是一种代码框架（大写的部分是伪代码）：

```python
map = [[0 for i in range(5)] for j in range(5)]
queue = {head:1,
        tail:2,
        data:[(0,0)]}   # start point of bfs
directions = ((0,1),(1,0),(-1,0),(0,-1))

while queue.head<queue.tail:
    for direction in directions:
        p = queue.data[head]+direction
        if IS_VALID(p) and not MAPPED(p):
            MARK(p)
            queue.data[tail++]=p
        if REACH_RESULT(P):
            flag=1
            break
    if flag==1:
        break
    head++

# print valid data point
printf(queue.data[tail])
```

# Chap5.图的遍历

## 深度优先和广度优先与图

### 什么是图

图由两个部分构成；

- 顶点  就是一些小圆点
- 边    也就是连接小圆点的线段

图的遍历就是指把图的每一个顶点都访问一次。由DFS方法访问图的所有顶点，并按照访问顺序对顶点标号，这标号就称为时间戳（timestamp）。

### 图的存储

**图的邻接矩阵存储法**：一般使用一个大小为节点数平方的矩阵存储图：$a_(ij)$表示图的i节点和j节点的联通情况。1表示有边，无穷表示没有边，0表示到自己。

>这里注意，无向图的矩阵是沿主对角线对称的。无向表示边的联通是双向的，有向则表示图是单向联通的。

使用DFS遍历图很简单：

```python
e = [[...]...]                  # array for a graph with n elements
map = [0 for i in range(n)]     # map： record checked node

def dfs(cur,sum=0):             # cur: id of current node
    print(cur)
    if ++sum == n:
        return
    for i in range(1,n):
        if e[cur][i] == 1 and map[i]==0:
            map[i]=1
            dfs(i,sum)
    return

dfs(1)                          # check all nodes from node#1
```

使用BFS遍历图也很简单：

>大致流程：从一个点开始，将它的相邻点放入处理队列，然后弹出它自身；再对下一个点进行处理，直到所有的点都被遍历。  
>代码随后写

```python
```

## 性能比较

图的边可以是单向的，也可以是双向的，在矩阵中相应修改即可。图中有一个计算最短路径的问题（也就是给图的边加上不同的权重），可以使用DFS算法解决。不过一定要注意标记当前路径处理过的顶点，防止出现死循环。

同样，也可以用BFS算法遍历图。和DFS一样，这种算法可以计算出最少边数的图，且耗时更短，而DFS则需要完全遍历后才能得到结果，在效率上低一些，且数据量越大越明显。

我们可以得出结论：深度优先能处理权重图的搜索和无权重图的搜索；而广度优先在无权重图搜索上速度更快。

# Chap6.最短路径

## Floyd-Warshall

## Dijkstra

## Bellman-Ford及其队列优化

## 最短路径算法对比分析

# Chap7.树

## 二叉树

## 堆（heap）

## 并查集

# Chap8.其他算法

## 图的最小生成树

## 图的割点

## 图的割边

## 二分图最大匹配
