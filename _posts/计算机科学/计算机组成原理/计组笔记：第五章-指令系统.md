---
title: 计组笔记：第五章-指令系统
date: 2023-06-17 20:07:32
author: xeonds
toc: true
excerpt: (*/ω＼*)
tags:
---

指令是硬件和软件的中间层。指令系统的设计主要包括**指令功能**和**指令格式**的设计。它的评价指标有四点：完备（不能缺少功能）、高效（省地方一点）、规整（格式简单一点）、兼容性（向后兼容，无成本迁移）四方面。

## 指令的基本格式

![](img/Pasted%20image%2020230617201110.png)

主要是两部分，首先是**操作码**，其次是数个地址（0个或多个）。将二进制编码用助记符表示，就是汇编语言。

计算机的存储方式有**大端存储（从数据的高字节开始存）、小端存储（从数据的低字节开始存）**

![](img/Pasted%20image%2020230617201456.png)

![](img/Pasted%20image%2020230617201611.png)

此外还有**边界对齐**的概念。如图所示：

![](img/Pasted%20image%2020230617201659.png)

还有一种存储模式，**堆栈**。这里的堆栈应该就是栈，堆和栈是俩不一样的东西，堆是存程序malloc的内存的，栈是存程序函数调用开销的，这俩在程序的内存中存储的位置也不一样。

存储模式也有两类：冯诺依曼结构（程序和数据等价）、哈佛结构（程序和数据不对等）。后者对于流水线结构有优化，能达到流水线的理想性能。现在的芯片内部Cache有的会使用哈佛结构：数据Cache、指令Cache，而外部使用冯诺依曼结构。

## 指令的典型分类

- 数据传送类：频率最高，要快
- 算数运算类
- 逻辑运算类
- 程序控制类
	- 转移
	- 循环
	- 过程调用、返回指令
	- 程序自中断指令
- 系统控制类：特权指令，虚存管理、任务切换、改变处理器工作模式
- 数据转换类：可选
- 输入输出类：根据统一编址（把接口的寄存器映射到主存，用数据传输指令访问外设）和独立编址，可能没有专门的输入输出指令。

## 寻址方式：指令获取操作数的方式

- 隐含寻址：例如Intel指令`MUL BL`，事先规定好了地址在哪
- 立即寻址：![](img/Pasted%20image%2020230617203658.png)
- 寄存器寻址：![](img/Pasted%20image%2020230617203717.png)
- 直接寻址：![](img/Pasted%20image%2020230617203731.png)
- 间接寻址：操作数地址的地址，需要访问两次主存，比较慢![](img/Pasted%20image%2020230617203746.png)
- 寄存器间接寻址：把上面的地址放在CPU内部寄存器![](img/Pasted%20image%2020230617203754.png)
- 基址寻址：用来实现主存分段 ![](img/Pasted%20image%2020230617203826.png)
- 变址寻址：用来实现数组遍历 ![](img/Pasted%20image%2020230617203835.png)
- PC相对寻址：PC指向下一条指令，这个方式给PC加偏移量，所以能用来实现与地址无关的程序设计![](img/Pasted%20image%2020230617203551.png)

例如，x86处理器的条件转移指令就是一种PC相对寻址。

![](img/Pasted%20image%2020230617204150.png)

无关位置的程序实现：

- 虚存管理：逻辑地址
- 内存分段管理：段内偏移

上面两种方案的缺点是位数多，占用指令存储空间大。

![](img/Pasted%20image%2020230617204711.png)

## 指令长度设计


- 一般原则
	- 指令长度为存储器**最小可寻址单位**的整数倍：（CISC）（x86）
	- 指令长度一般为**总线宽度**的整数倍：RISC
- 常用设计方案
	- 变长操作码，变长指令码：CISC（x86）
	- 定长操作码，定长指令码：RISC
		- MIPS，6位定长操作码，32位定长指令码
		- RISC-V，7位定长操作码，32位定长指令码


**操作码**格式分为**定长、变长操作码**，变长操作码为了防止重复指令，得用赫夫曼编码来编制操作码。

1. 定长操作码

对于定长操作码，可以将指令从高频到低频排序，依次给从0开始编号。

- 优点：操作码构造简单，硬件设计简单，译码速度快
- 缺点：操作码占存储空间大，难以扩展

2. 变长操作码

对于变长操作码，按照频率高到低排序，再构造霍夫曼树作为编码结果。

变长操作码设计原则：
- 若指令字长度固定，则长地址码对应短操作码，操作码长度随地址码长度缩短而增加
- 如果指令字长度可变，则以指令使用频率为设计依据，高频短码，低频长码
- 设计总是**从短码开始**，并且保证现在的操作码和以后扩展的编码能区分
- **短码不能是长码的前缀**

根据赫夫曼编码的合并方式不同，得到的结果可能不唯一，但是**平均码长一定是唯一的**

缺点：编码长度种类过多，电路设计困难

![](img/Pasted%20image%2020230617205817.png)

3. 扩展操作码

是将赫夫曼编码的码长变为更少的种类。

![](img/Pasted%20image%2020230618013331.png)

可以看到，它编码种类较少的同时，码长也很接近赫夫曼编码。因此实际设计时，一般使用这种设计方式。比如CISC的x86就可以这么设计。

![](img/Pasted%20image%2020230617210813.png)

上面是两种设计方式。一个长度的指令码必须保留一种组合给更长的指令码做前缀。

![](img/Pasted%20image%2020230618013746.png)

因此，上面的操作码可以设计如下：

- 三地址：操作码6位，指令数$n_3\leq2^6-1$
- 双地址：操作码11位，指令数$n_2\leq(2^6-n_3)\cdot2^5-1$
- 单地址：操作码16位，指令数$n_1\leq((2^6-n_3)\cdot2^5-n_2)\cdot2^5-1$
- 零地址：操作码32位，指令数$n_0\leq(((2^6-n_3)\cdot 2^5 - n_2)\cdot2^5-n_1)\times2^{16}$

![](img/Pasted%20image%2020230618014509.png)

对于上面的问题，相当于计算单地址指令一共有多少个。我们分析如下：

![](img/Pasted%20image%2020230618014832.png)

由上图的不等式能解出来，B类指令最多一共有254条。

![](img/Pasted%20image%2020230617211810.png)

上题还是从短码开始考虑。首先短码有m条，则剩下的前缀有$2^4-m$个。再乘以长码扩展的长度$2^6$，就能得到长码最多的个数。

![](img/Pasted%20image%2020230618015643.png)

![](img/Pasted%20image%2020230618015933.png)

![](img/Pasted%20image%2020230617213025.png)

## 5.6.典型指令系统

### Intel x86

发展：从诞生时的80条指令增长到2015的3600条指令（来源Intel博客）。

十分复杂，指令集手册5000多页（

目前在向着RISC的方向均衡。它十分适合高性能计算。

### MIPS

ARM手册也长，8000多页（

32位MIPS

![](img/Pasted%20image%2020230618023229.png)

64位MIPS，14种指令格式

![](img/Pasted%20image%2020230618023357.png)

MIPS是arm流行之前，最流行的处理器。

这一章基本就是这样了。