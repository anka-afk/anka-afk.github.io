{"posts":[{"title":"Rust学习","text":"参考视频：【Rust 编程语言入门教程（Rust 语言/Rust 权威指南配套）【已完结】】 https://www.bilibili.com/video/BV1hp4y1k7SV/?p=12&amp;share_source=copy_web&amp;vd_source=faa4d83326aa65fa16123ce1d49425a3 我将采用注释式笔记, 也就是所有知识都用代码文件存放, 在注释中写明知识点 [[猜数游戏]][[rust变量类型]]","link":"/2024/04/17/Rust/"},{"title":"Rust变量类型","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293fn main() { println!(&quot;Hello, world!&quot;); // 不可变变量 let mut x = 5; println!(&quot;x的值是:{}&quot;,x); x = 6; println!(&quot;x的值是:{}&quot;,x); // 常量也是不可变的,但是不可约使用mut,永远都不可变 // 声明常量必须使用const // 声明常量必须标注类型 // 常量可以在任何作用域声明,包括全局作用域 // 常量只能被设置为常量表达式,不能是函数调用的结果,或任何其他只能在运行时计算得到的值 // 常量在运行期间总是存在的,并且它们在任何作用域中都可以被访问 // 常量使用全大写字母和下划线命名,并且下划线可以用来增加可读性 // 数字中间可以插入下划线来增加可读性 const MAX_POINTS:u32 = 100_000; // 隐藏变量 // 可以用同样的名字声明一个新变量,而新变量会隐藏之前的变量 let x = 5; println!(&quot;x的值是:{}&quot;,x); let x = x + 1; println!(&quot;x的值是:{}&quot;,x); // 虽然x是不可变的,但是可以用let关键字来声明一个新变量,这样就可以隐藏之前的变量 // 相当于override let x = x * 2; println!(&quot;x的值是:{}&quot;,x); // shadow和把变量标记为mut是不一样的 // 用let声明的新变量也是不可变的 // 使用let声明的同名新变量的类型可以和之前的不一样 let spaces = &quot; &quot;; let spaces = spaces.len(); // 这里把spaces的类型从字符串变成了数字,但是名字还是spaces,其实是一个新的变量,同名隐藏掉原来的变量 // 如果这里不加let,会报错,因为变量是不可变的 println!(&quot;spaces的值是:{}&quot;,spaces); // 数据类型 // Rust是静态类型语言,必须在编译时知道所有变量的类型 // 如果可能的类型比较多,例如parse方法,就必须添加类型的标注 let guess:u32 = &quot;43&quot;.parse().expect(&quot;不是个数!&quot;); // 如果不标注是u32类型,会报错 println!(&quot;guess的值是:{}&quot;,guess); // 标量类型 // 标量类型代表单个的值 // rust一共有四个主要的标量类型:整数,浮点数,布尔类型,字符类型 // 整数类型 // 有符号整数:i8,i16,i32,i64,i128,isize // 无符号整数:u8,u16,u32,u64,u128,usize // isize和usize类型依赖运行程序的计算机架构:64位计算机上是64位,32位计算机上是32位 // 默认是i32类型 // 除了byte类型,其他类型都可以用类型后缀来标注,例如123u32 // 整数溢出 // Rust在编译时会检查是否有整数溢出,如果有,会报错 // debug模式下会panic,release模式下会wrap,例如256u8会变成0,257u8会变成1 // 例如:let x:u8 = 256;会报错 // 浮点数类型 // rust有两种浮点数类型:f32和f64 // 默认是f64类型 let x = 2.0; let y:f32 = 3.0; // 数值操作 // 加法 let sum = 5 + 10; let difference = 95.5 - 4.3; let producy = 4 * 30; let quotient = 56.7 / 32.2; let reminder = 54 % 5; // 布尔类型 // rust有两个布尔值:true和false // 布尔类型的大小是1个字节 // 布尔类型的值是bool类型 let t = true; let f:bool = false; // 字符类型 // Rust的char类型是单个Unicode字符,可以表示比ASCII更多的字符,例如中文,日文,韩文等,甚至是emoji表情 // Rust的char类型是4个字节 // Rust的char类型用单引号表示 // Unicode中没有字符的概念,只有代码点,代码点是一个数字,代表一个字符 let x = 'z'; let y:char = '😻'; let z = '中'; println!(&quot;x的值是:{}&quot;,x); println!(&quot;y的值是:{}&quot;,y); println!(&quot;z的值是:{}&quot;,z); // 复合类型 // Rust有两个复合类型:元组和数组 // 元组可以将多个不同类型的值组合在一起 // 数组可以将多个相同类型的值组合在一起 // 元组tuple // 元组是一个将多个其他类型的值组合在一起的复合类型 // 元组的长度是固定的,一旦声明,就不能增加或减少 let tup:(i32,f64,u8) = (500,6.4,1); // 获取tuple的值 // 可以使用模式匹配来解构一个tuple来获取元素的值 let (x,y,z) = tup; println!(&quot;x的值是:{}&quot;,x); println!(&quot;y的值是:{}&quot;,y); println!(&quot;z的值是:{}&quot;,z); // 访问tuple的元素 // 使用点号和索引来访问tuple的元素 println!(&quot;{},{},{}&quot;,tup.0,tup.1,tup.2); // 数组 // 数组是一个将多个相同类型的值组合在一起的复合类型 // 数组的长度是固定的,一旦声明,就不能增加或减少 // 数组的类型标注是[Type;size],例如:[i32;5] // 数组的元素可以通过索引访问,索引从0开始 let a = [1,2,3,4,5]; let b:[char;5] = ['a','b','c','d','e']; // 如果想把数据存在stack(栈)上而不是heap(堆)上就可以使用数组 // 如果想保证有固定数量的元素,也可以使用数组 // 数组没有Vector灵活 // Vector是可以改变长度的,数组是固定长度的 let months = [&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;]; // 这种不会变长度的就适合用数组 // 如果每个元素都相同,还有一种语法 let a = [3;5]; // 这样就会生成一个包含5个3的数组 // 访问数组元素 // 数组是栈上的单个块的内存 let first = months[0]; let second = months[1]; println!(&quot;first的值是:{}&quot;,first); println!(&quot;second的值是:{}&quot;,second); // 如果访问的索引超过了数组的范围,会报错panic // rust不允许其继续访问相应地址的内存,这样可以避免潜在的安全漏洞 // 不允许越界,只能访问数组占的内存空间 // 例如:let index = 10;let element = a[index];会报错 // 有时不会报错,例如:let index = [12,13,14,15]; let month = months[index[1]];可以通过编译,但是运行时会报错index out of bounds,程序panic}","link":"/2024/04/17/rust%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"title":"Rust猜数游戏","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104use std::io; // prelude 序曲use rand::Rng; // trait 是其他语言的接口,上面有很多方法use std::cmp::Ordering; // 是一个枚举类型,有三个值,大于,小于,和等于// rust的库称为crate,crate是一个二进制或库,库是一个包含函数和其他代码的包,二进制crate是一个可以被执行的包,每个crate都有一个crate root,这是一个源文件,编译器从这个文件开始并编译整个crate,crate root是一个源文件,而不是一个目录,一个crate可以包含多个库,但只能包含一个二进制crate// crate分为二进制crate还有lib库,二进制crate是一个可以被执行的包,lib库是一个包含函数和其他代码的包,但不能被执行,只能被其他crate引用 fn main() { println!(&quot;猜数!&quot;); // rng是个接口,上面一个函数gen_range,范围是1-100,包括1,不包括101 let secret_number = rand::thread_rng().gen_range(1..101); // println!(&quot;神秘数字是:{}!&quot;, secret_number); // 使用loop循环,无限循环,直到猜对为止 loop{ println!(&quot;猜测一个数:&quot;); // let mut foo = 1; // let bar = foo; // immutable // 要表示0到100的范围,使用u32,无符号32位整数,默认是i32,有符号32位整数,也可以i64 let mut guess = String::new(); // 产生Stdin实例,存句柄,用read_line方法用可变的字符串参数获取输入,前面&amp;表示是引用传递参数,引用默认是不可变的,需要加入mut参数,readline返回Result类型变量,是枚举类型,值称为变体,两个变体:ok和err,ok变体包含一个元组,元组的第一个元素是一个引用,指向一个字符串,这个字符串是readline方法读取的内容,err变体包含一个错误值 // Result上还定义了方法expect,如果是ok,则这个方法会提取里面的值,如果返回err,则expect会使程序崩溃,并显示传递给expect的参数,显示失败原因 // 不调用expect方法也行,但是会出现警告,安全性保证 io::stdin().read_line(&amp;mut guess) .expect(&quot;无法读取行&quot;); // rust允许使用同名的新变量来隐藏之前的变量 // trim方法去掉字符串前后的空白字符,parse方法将字符串转换为数字,parse方法返回Result类型,所以需要expect方法 let guess:u32 = match guess.trim().parse(){ Ok(num) =&gt; num, Err(_) =&gt; continue, }; // parse方法将字符串转换为数字,parse方法返回Result类型,所以需要expect方法 // 声明u32是为了告诉parse()方法,我们想要一个u32类型的数字,如果不声明,parse()方法会返回一个通用数字类型,这样就需要告诉编译器我们想要的类型 // 这之后的guess是一个新的变量,是一个u32类型,之前的guess是一个字符串类型 // 花括号是后面变量的值,用来在字符串中插入变量值 println!(&quot;你猜测的数是: {}&quot;, guess); // 方法guess.cmp,compare,三种情况,使用一个枚举类型 // match表达式,根据后面返回值决定做什么,多个手臂arm组成,每个手臂都有一个匹配的模式,匹配上就执行操作 // 如果match紧跟着的某个值和某个手臂的模式匹配,就会执行这个手臂的代码块 // 静态强类型语言 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(&quot;太小了!&quot;), // arm Ordering::Greater =&gt; println!(&quot;太大了!&quot;), Ordering::Equal =&gt; { println!(&quot;猜对啦!&quot;); break; }, } }}","link":"/2024/04/17/%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/"}],"tags":[],"categories":[],"pages":[{"title":"关于我","text":"PROF1LE 兴趣/习惯是写代码。闲了喜欢整点小玩意玩。 游戏玩的不多，一直断断续续在玩的只有mc。 Homepage (zh) (in maintaince) | Blog (mirror) 咱的项目 Gin+Vue构建的RSS博客聚合站 使用Go+Vue+Docker实现的分布式OJ系统 数据库大作业，公交调度管理系统 Flutter练手作，复刻AutoSync。另外还有个用Flutter填坑的MCSM Panel，但是这东西用的不多也就没咋积极更新了 另外这个博客的发布也借助GitHub Action实现了自动化编译发布，详见这里和我的workflow配置文件。","link":"/about/index.html"},{"title":"友情链接","text":"小伙伴们Robotxm：能用电表得感谢这位SuperBart：能查水表得感谢这位Holynia：哎 二次元Albert：事TIS的成员，但真的好能鸽Ray：啥时候办个计算机文物展子吧（ComeIntoCalm:ACM的跌Dimole：hacked by Dimole（逃康师傅：(╹ڡ╹ )孤筝の温暖小窝：Ciallo～(∠・ω&lt; )⌒☆bszydxh：b师傅怎么啥都会啊（膜Reverier’s Blog：rx师傅教我写ruast吧（做梦Canxin Site：怎么一个两个都写Ruast啊 想要交换友链的朋友们可以在下方留言 咱看到了会加上的(*/ω＼*)","link":"/links/index.html"}]}